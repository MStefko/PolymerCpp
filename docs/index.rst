.. PolymerCpp documentation master file, created by
   sphinx-quickstart on Wed May 31 07:03:27 2017.
   You can adapt this file completely to your liking, but it should at least
   contain the root `toctree` directive.

PolymerCpp
==========

3D wormlike chain generator for Python and written in C++.

.. image:: _images/wlc_realization.png

.. toctree::
   :maxdepth: 2
   :caption: Contents:

About
=====

PolymerCpp is a small program for generating three-dimensional
wormlike chains (WLC), a common and relatively simple model in polymer
physics. A WLC describes a semi-flexible polymer, i.e. one that is
rigid over short length scales and flexible over long ones. The
characteristic length scale that separates these two regimes is known
as the persistence length.

PolymerCpp provides a number of Python functions that exposes the C++
routines for generating 3D WLCs, including

1. infinitesimally thin WLCs
2. self-avoiding WLCs

PolymerCpp was written by `Marcel Stefko
<https://github.com/MStefko>`_ and `Kyle M. Douglass
<https://github.com/kmdouglass>`_ in the `Laboratory of Experimental
Biophysics <http://leb.epfl.ch/>`_ for modeling DNA.

User Guide
==========

Installation
------------

Nix
+++

Install PolymerCpp into your current profile::

  nix-env -f PolymerCpp.nix -i '.*'

Activate an interactive shell with Python and the PolymerCpp package
without actually installing PolymerCpp::

  nix-shell shell.nix --pure

Source Installs
+++++++++++++++

Install the Python package::

  python setup.py

Compile just the shared library::

  make

Chain Simulation
-----------------

To begin, start the Python interpreter and import the function to
generate wormlike chains into the session's namespace::

  >>> from PolymerCpp.helpers import getCppWLC

A single realization of an infinitesimally thin wormlike chain
requires two input arguments: the chain length and the persistence
length::

  >>> pathLength = 500
  >>> persisLength = 50

A single realization of the chain is generated by a call to
getCppWLC.::

  >>> chain = getCppWLC(pathLength, persisLength)

A self-avoiding WLC may also be simulated. This requires setting the
diameter of the exclusion volume centered around each chain
segment. The diameter is also specified in units of chain segments and
cannot exceed 1::

  >>> from PolymerCpp.helpers import getCppSAWLC
  >>> linkDiameter = 0.75
  >>> chain = getCppSAWLC(pathLength, persisLength, linkDiameter)

Verification of the Algorithms
------------------------------

PolymerCpp.algorithms contains a utility function that performs two
numerical experiments for verifying the accuracy of the algorithm. In
the first, it calculates chain realizations for a given number of
groups and a given number of chain realizations in each for each
group. The mean end-to-end distance `R` and mean radius of gyration
`Rg` is computed for each group and a histogram of the results is
displayed. The x-axis is the difference between the computed mean and
the theoretical mean.

In the second experiment, a number of chains equal are simulated for a
range of chain contour lengths.  The mean end-to-end distance and mean
radius of gyration for each group is then plotted vs. the contour
length, along with the theoretical predications. The error bars denote
the standard deviation of the group.::

  from PolymerCpp.algorithms import verify_WLC
  verify_WLC(getCppWLC)

This will print a summary to the console and display a figure similar
to the following:

.. image:: _images/verify_wlc.png

You may change a number of settings by specifying arguments to the
function::

  verify_WLC(getCppSAWLC,
             num_chains=50,
	     num_experiments=500,
	     contour_length=800,
	     persistence_length=20,
	     linkDiameter=0.5)

Algorithm
=========

Wormlike Chain
--------------

The WLC algorithm is based on the original `Kratky-Porod model`_ of a
continuous semiflexible polymer. The chain is approximated as a series
of discrete segments of equal length. For each successive segment, let
the previous segment lie along the z-axis. The zenith angle for the
current segment is determined by a random number drawn from a normal
distribution whose standard deviation is

.. math::

   \sigma = \sqrt{ \frac{2}{\ell_p} }

where :math:`\ell_p` is the persistence length of the chain. The
azimuth angle is a uniform random number between 0 and :math:`2 \pi`.

The self-avoiding WLC is modeled a series of spheres whose
center-to-center distance is fixed for successive spheres. For each
successive segment, a candidate sphere is generated and checked for
collisions with other spheres in the chain. If there is a collision,
the sphere is erased and another sphere is generated.

Bias
----

In the current version of the code, the end-to-end distances and the
radius of gyration of the wormlike chain exhibits a bias relative to
the theoretical predictions. This may be seen in the output of
`verify_WLC()` above. The mean values of a large ensemble of chains
are consistently smaller than the theoretical values.

We are currently looking into the source of this bias but have not yet
identified it. For the time being, please take note of its existence.

.. _`Kratky-Porod model`: https://en.wikipedia.org/wiki/Worm-like_chain
	     
Indices and tables
==================

* :ref:`genindex`
* :ref:`modindex`
* :ref:`search`
